package org.mmarini.scala.railways

import rx.lang.scala.Observable
import rx.lang.scala.Subject
import rx.lang.scala.Subscription
import com.jme3.collision.CollisionResult
import com.jme3.math.Ray
import com.jme3.collision.CollisionResults
import com.jme3.math.Vector2f
import org.mockito.cglib.proxy.LazyLoader
import com.typesafe.scalalogging.LazyLogging

/**
 * @author us00852
 */

trait PositionMapping {
  def position: Vector2f
}

trait Mapping {
  def name: String
  def tpf: Float
}

case class ActionMapping(name: String, keyPressed: Boolean, position: Vector2f, tpf: Float) extends Mapping with PositionMapping
case class AnalogMapping(name: String, value: Float, position: Vector2f, tpf: Float) extends Mapping with PositionMapping

case class RayMapping(ray: Ray, mousePos: Vector2f)

class ObservableFactory[T](subject: Observable[T]) extends LazyLogging {

  def hash(o: Any) = o.hashCode.toHexString.takeRight(4)

  /** Creates an observable that emits a sequence of last n values emitted */
  def history[T](length: Int): Observable[Seq[T]] =
    subject.scan(Seq[T]())(
      (seq, current) => {
        val tail = seq.take(length - 1)
        current +: tail
      })

  /**
   * Creates an observable that emits just the last value of  a variable
   * since creation instant
   * The first value will be emitted with sampled observable the further values are immediate
   */
  def latest[T]: Observable[T] = {
    var value: Observable[T] = subject.take(1)
    a.subscribe(x => value = Observable.just(x),
      ex => value = Observable.error(ex),
      () => {})
    Observable.defer(value)
  }

  def traced[T](id: String): Observable[T] = {
    var ct = 0
    Observable.create[T](obsr => {
      ct = ct + 1
      val traceId = s"${hash(subject)}.$ct.${hash(obsr)} $id"
      logger.debug("{} subscribe", traceId)
      val sub = subject.subscribe(
        x => {
          logger.debug("{} onNext {}", traceId, String.valueOf(x))
          obsr.onNext(x)
        },
        e => {
          logger.error("$traceId error", traceId, e)
          obsr.onError(e)
        },
        () => {
          logger.debug("{}on Completed", traceId)
          obsr.onCompleted
        })
      Subscription {
        logger.debug("{} unsubscribe", traceId)
        sub.unsubscribe()
      }
    })
  }

  def trace[T](msg: String = "") = {
    traced(msg).subscribe
  }

  /**
   * Creates an observable that emits the value created at
   * first emission of observable since first subscription
   */
  def onFirstObs[T, R](t: Observable[T])(f: T => R = (x: T) => x): Observable[R] = {
    val fo = for { t <- t.take(1) } yield f(t)
    val fc = latest(fo)
    fc
  }

  /**
   * Creates an observable that emits the values
   * first observable emitted by observable since first subscription
   */
  def onFirstFlattenObs[T, R](t: Observable[T])(f: T => Observable[R]): Observable[R] =
    onFirstObs(t)(f).flatten

  /**
   * Creates an observable that emits the value created when
   * first two trigger observables will be emitted since first subscription
   */
  def onFirstObs[T, V, R](
    t: Observable[T],
    v: Observable[V])(
      f: (T, V) => R): Observable[R] = {

    val fo = (for {
      t <- t.take(1)
    } yield {
      val r = for { va <- v.take(1) } yield f(t, va)
      val rc = latest(r)
      trace("rc", rc)
      rc
    })
    val fc = latest(fo)
    fc.flatten
  }

  /**
   * Creates an observable that emits the value composed by trigger observable and
   * previous value of sampling observable
   * or optional default values if no previous value available
   */
  def withLatest[T, S, R](trigger: Observable[T], value: Observable[S])(f: (T, S) => R = (t: T, s: S) => (t, s)): Observable[R] = {
    val latestSample = latest(value)
    val x = for { t <- trigger } yield for { v <- latestSample } yield f(t, v)
    x.flatten
  }

  /** State flow */
  def stateFlow[T](o: Observable[T => T])(init: Observable[T]): Observable[T] = {
    var s: Option[T] = None
    init.take(1).subscribe(x => { s = Option(x) })
    val subj = Subject[T]
    o.dropUntil(init).subscribe(
      f => {
        s = for { sv <- s } yield {
          val s1 = f(sv)
          subj.onNext(s1)
          s1
        }
      },
      ex => subj.onError(ex),
      () => subj.onCompleted)
    subj
  }

  /** Returns the observable of pick ray */
  //  def pickRay(o: Observable[PositionMapping]): Observable[RayMapping] =
  //    for { _ <- o } yield {
  //      val mousePos = app.getInputManager.getCursorPosition
  //      val cam = app.getCamera
  //      val pos = cam.getWorldCoordinates(new Vector2f(mousePos), 0f).clone()
  //      val dir = cam.getWorldCoordinates(new Vector2f(mousePos), 1f).subtractLocal(pos).normalizeLocal()
  //      RayMapping(new Ray(pos, dir), new Vector2f(mousePos))
  //    }
  //
  //  /** Returns the observable of pick object */
  //  def pickCollision(shootables: Node)(o: Observable[RayMapping]): Observable[(CollisionResult, RayMapping)] = {
  //    val collisions = for { rayMapping <- o } yield {
  //      val results = new CollisionResults()
  //      shootables.collideWith(rayMapping.ray, results)
  //      (results, rayMapping)
  //    }
  //    for {
  //      (cr, ray) <- collisions
  //      if (cr.size() > 0)
  //    } yield (cr.getClosestCollision(), ray)
  //  }

}